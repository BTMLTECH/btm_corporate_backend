#!/usr/bin/env python3
# File: user_repository.py
# Author: Oluwatobiloba Light
"""User Repository"""

from email.mime.text import MIMEText
from smtplib import SMTP
from typing import Callable, Mapping, TypeVar, Union
from uuid import uuid4
from fastapi.encoders import jsonable_encoder
from psycopg2 import IntegrityError
from pydantic import EmailStr
from sqlalchemy import select, text, update
from app.core.exceptions import DuplicatedError
from app.model.user import User
from app.repository.base_repository import BaseRepository
from sqlalchemy.ext.asyncio import (
    AsyncSession,
)

T = TypeVar("T", bound=User)


class UserRepository(BaseRepository):
    def __init__(self, session_factory: Callable[[], AsyncSession]):
        self.session_factory = session_factory
        self.model = User

        super().__init__(session_factory, User)

    async def create(self, schema: T) -> User:
        """
        Creates a user in the database.
        """
        async with self.session_factory() as conn:
            query = self.model(**schema.model_dump())

            try:
                conn.add(query)
                await conn.flush()
                await conn.refresh(query)
            except IntegrityError as e:
                await conn.rollback()
                raise DuplicatedError(detail=str(e.orig))
            except Exception as e:
                if "duplicate" in str(e).lower():
                    error_msg = "An account with that email address exists!"
                    raise DuplicatedError(detail=error_msg)
                else:
                    print(f"Other integrity error: {str(e)}")
                    raise DuplicatedError(detail=str(e))
            return query

    async def get_by_email(self, email: EmailStr, eager: bool = False) -> Union[User, None]:
        """
        Get a user by their email
        """
        async with self.session_factory() as conn, conn.begin():
            try:
                query = (await conn.execute(
                    self.model.__table__.select().where(self.model.email == email)
                )).fetchone()
                # return query.fetchone()
                if query is None:
                    return None
                return User(**query._asdict())
            except Exception as e:
                print("An error has occured", e)
                raise e

    async def send_sign_up_verification_email(self, email: EmailStr, token: str, expiration_time: int = 15):
        """"""
        # Configuration
        port = 587
        smtp_server = "mail.btmghana.net"
        login = "info@btmghana.net"  # Your login generated by Mailtrap
        password = "BTMGH@N@123."  # Your password generated by Mailtrap

        sender_email = "info@btmghana.net"
        receiver_email = "oluwatobilobagunloye@gmail.com"

        # generate id
        token_id = str(uuid4())

        verification_data = {
            "id": token_id,
            "email": email,
            "token": token
        }

        # Plain text content
        text = """\
        Hi,
        Thanks for signing up on BTM Ghana!
        To complete your registration, please click on the link below to verify your email address:

        http://127.0.0.1:5173/verify?token={0}

        If you didn't request this email, please ignore it.

        Best regards,
        BTM Ghana
        btmghana.net
        """.format(token_id)

        # Create MIMEText object
        message = MIMEText(text, "plain")
        message["Subject"] = "BTM Ghana - Email Verification"
        message["From"] = sender_email
        message["To"] = receiver_email

        # set token in redis here
        from app.util.redis import redis_client

        try:

            # Send the email
            with SMTP(smtp_server, port) as server:
                server.starttls()  # Secure the connection
                server.login(login, password)
                server.sendmail(sender_email, receiver_email,
                                message.as_string())

            redis_client.set(token_id, verification_data,
                             expiry_seconds=60*expiration_time)
            return True
        except Exception as e:
            raise e

        return False

    async def reset_password(self, email: EmailStr):
        """"""

    async def verify_sign_up(self, token: str) -> bool:
        """Verify a user after sign up"""
        from app.util.redis import redis_client

        verification_data = redis_client.get(token)

        print("verification_data", verification_data)

        if verification_data is None:
            return False

        # update verified status

        user = await self.get_by_email(verification_data['email'])

        if user is None:
            return False

        redis_client.delete(token)

        return True

    async def update(self, schema: T, updated_fields: dict[str, any]) -> Union[User, None]:
        """Updte user record in the DB"""
        async with self.session_factory() as conn, conn.begin():
            q = (update(self.model).where(self.model.email ==
                 schema.email).values(**updated_fields))

            try:
                user = (await conn.execute(q))
                await conn.commit()

                if user is None:
                    return None

                return User(**jsonable_encoder(schema))
            except Exception as e:
                await conn.rollback()
                raise e
            finally:
                await conn.close()
